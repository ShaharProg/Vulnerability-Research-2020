#include <stdio.h> 
#include <stdlib.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <stdlib.h> 
#include <unistd.h>
#include <iostream>
#include <sys/syscall.h>
#include <fstream>
#include <string.h> 
#include <arpa/inet.h>
#include <sys/socket.h> 
using namespace std; 
#include <vector>  
#include <sys/types.h> 
#define MAX 8 
#define PORT 8081

#define SA struct sockaddr 


class Object {
    public:
        size_t id;
        size_t size;
        void *data;

        virtual void print_data(){
            printf("hello\n");
        } 
};




class Connection{
    int sockfd;
    char buff[MAX]; 
    int n; 
    int header = 0x11223344;
    vector<Object*> object_list;
    public:
        Connection(int sock){sockfd = sock;start();}
    private:
        void clean_conn(){
            int bytes_read = 0;
            while(1) {
                bytes_read = recv(sockfd, buff, sizeof(header),0);
                printf("bytes read %x sdf\n",bytes_read);
                if (bytes_read  == 0){
                    //exit(0);
                    return;
                }
            } 
        }
        int get_new_object(){
            Object* obj = new Object();
            printf("DBG: object ptr: %p\n",obj);
            recv(sockfd, &obj->size, sizeof(obj->size),0);
            printf("Got size %d\n",obj->size);
            obj->data = malloc(obj->size);
            obj->id = (size_t)object_list.size();
            recv(sockfd, obj->data, obj->size,0);
            printf("Got data %4s\n",obj->data);
            object_list.push_back(obj);
            return obj->id;
        }

        int get_update_object(){
            size_t id = 0;
            size_t size =0;
            Object* obj;
            printf("update object \n");
            recv(sockfd, &id, sizeof(id),0);
            if (id >= object_list.size()){
                return -1;
            }
            obj = object_list[id];
            recv(sockfd, &size, sizeof(size),0);
            recv(sockfd, obj->data, size,0);
            return id;
        }
        
        int get_read_object(){
            size_t id = 0;
            size_t size =0;
            Object* obj;
            printf("read object \n");
            recv(sockfd, &id, sizeof(id),0);
            if (id >= object_list.size()){
                return -1;
            }
            obj = object_list[id];
            printf("returning data: in size %x\n",obj->size);
            write(sockfd, obj->data, obj->size); 
            return id;
        }
        
        void print_object(){
            size_t id = 0;
            
            Object* obj;
            printf("read object \n");
            recv(sockfd, &id, sizeof(id),0);
            if (id >= object_list.size()){
                return;
            }
            obj = object_list[id];
            obj->print_data();
        }

        void start(){
            for (;;) { 
                int bytes_read;
                int read_header = 0;
                bytes_read = recv(sockfd, &read_header, sizeof(read_header),0);
                if (bytes_read == -1){
                    printf("Problem with socket\n");
                    exit(1);
                }
                printf("bytes: read %d \n",bytes_read);
                if (read_header != header){
                    printf("Header invalid %x %x \n",read_header,header);
                    //clean_conn();
                    exit(1);
                    continue;
                }
                printf("Got Header\n");
               
                int type=0;
                recv(sockfd, &type, sizeof(type),0);
                unsigned int id =0;
                switch(type){
                    case 0: 
                        id = get_new_object();
                        break;
                    case 1: 
                        id = get_update_object();
                        break;
                    case 2:
                        id = get_read_object();
                        break;
                    case 3:
                        print_object();
                        break;
                }
                printf("writing id: %x\n",id);
                write(sockfd,&id,sizeof(id));
            } 
        }
};

// Driver function 
int main() 
{ 
    printf("started\n");
    int sockfd, connfd, len; 
    struct sockaddr_in servaddr, cli; 
  
    // socket create and verification 
    sockfd = socket(AF_INET, SOCK_STREAM, 0); 
    if (sockfd == -1) { 
        printf("socket creation failed...\n"); 
        exit(0); 
    } 
    else
        printf("Socket successfully created..\n"); 
  
  
    // assign IP, PORT 
    servaddr.sin_family = AF_INET; 
    servaddr.sin_addr.s_addr =  inet_addr("127.0.0.1"); 
    servaddr.sin_port = htons(PORT); 
  
    // Binding newly created socket to given IP and verification 
    if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0) { 
        printf("socket bind failed...\n"); 
        exit(0); 
    } 
    else
        printf("Socket successfully binded..\n"); 
  
    // Now server is ready to listen and verification 
    if ((listen(sockfd, 5)) != 0) { 
        printf("Listen failed...\n"); 
        exit(0); 
    } 
    else
        printf("Server listening..\n"); 
    len = sizeof(cli); 
  
    // Accept the data packet from client and verification 
    connfd = accept(sockfd, (SA*)&cli, (socklen_t* )&len); 
    if (connfd < 0) { 
        printf("server acccept failed...\n"); 
        exit(0); 
    } 
    else
        printf("server acccept the client...\n"); 

    printf("Starting conn\n");
    // Function for chatting between client and server 
    Connection conn(connfd);
  
    // After chatting close the socket 
    close(sockfd); 
} 