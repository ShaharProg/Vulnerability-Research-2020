#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define ARRAY_SIZE(x)   (sizeof(x)/sizeof(x[0]))

struct obj {
    int i;
};

struct obj *obj_arr[1024];

int alloc_obj(int *objid)
{
    size_t i = 0;
    for (i =0; i < ARRAY_SIZE(obj_arr); ++i) {
        if (obj_arr[i] == NULL) {
            obj_arr[i] = malloc(sizeof(struct obj));
            *objid = i;
            return 0;
        }
    }
    return -1;
}

int free_obj(int *objid)
{
    if (*objid < 0 || *objid > ARRAY_SIZE(obj_arr)) {
        return -1;
    }
    if(obj_arr[*objid] != NULL) {
        free(obj_arr[*objid]); //double free
    }
}

typedef struct {
    int id;
    struct obj data;
} get_set_data;

int set_obj(void *_data)
{
    get_set_data *data = (get_set_data *)_data; 
    if (data->id < 0 || data->id > ARRAY_SIZE(obj_arr)) {
        return -1;
    }
    if (obj_arr[data->id] != NULL) {
        memcpy(obj_arr[data->id], &data->data, sizeof(struct obj)); //copy to freed memory
    }
    return 0;
}

int get_obj(void *_data)
{
    get_set_data *data = (get_set_data *)_data;
    if (data->id < 0 || data->id > ARRAY_SIZE(obj_arr)) {
        return -1;
    }
    if (obj_arr[data->id] != NULL) {
        memcpy(&data->data, obj_arr[data->id], sizeof(struct obj)); //copy from freed memory
    }
    return 0;
}

typedef void *(* pthread_func)(void *);



int main(int argc, char *argv[])
{
    char op = 0;
    int id;
    int data;
    struct obj obj;
    get_set_data gs_data;
    pthread_t thread;

    while (op != 'q') {
        scanf("%c", &op);

        if (op != 'a') {
            scanf("%d", &id);
        }
        switch (op) {
        case 'a':
            pthread_create(&thread, NULL, (pthread_func)alloc_obj, &id);
            printf("obj_id is %d\n", id); //can print before the thread is finish
            break;
        case 'f':
        pthread_create(&thread, NULL, (pthread_func)free_obj, &id);
        break;
        case 's':
        case 'g':
        gs_data.id = id;
        scanf("%d", &data);
        gs_data.data.i = data;
        if ((op) == 's') {
            pthread_create(&thread, NULL, (pthread_func)set_obj, &gs_data);
        }else {
            pthread_create(&thread, NULL, (pthread_func)get_obj, &gs_data);
            printf("data is %d\n", gs_data.data.i); //can print before the thread is finish
        }
        }
    }
    
}